\documentclass[../Notes.tex]{subfiles}


\begin{document}
\chapter{DP}

Write recurrence relation for a problem. When we draw a directed graph from the recurrence(i.e draw edge from state $s_i$ to all the subproblems it requires to find dp[$s_i$](i.e the right side of recurrence states)). Then in order to solve the problem using dp the graph should be acyclic. (If not we cannot come to the answer with this dp alone, even though the recurrences are correct. You can even check if recurrences are correct between states after finding out answers with some other algorithm).

On the above graph there are three ways to solve.
\begin{itemize}
	\item Topdown dp.
	\item bottom up dp.
	\item forward dp.
\end{itemize}	
Some Points to note
\begin{itemize}
	\item Counting problems either involves combinatorics or dp and nothing else.
	\item There are counting DP problem's where we need to find no of ways to pair or group elements. We can have dp with one dimension representing no of groups which are not closed yet. This can be used both in arrays, trees etc.  
	\item we proove most optimization dp's using this kind of proving techniques.
	\href{Material/dpproof.pdf}{proof}.\pagebreak
	\item while solving optimization dp(topdown,bottomup,forward), Keep another array 'prev' which stores the state from which this state's answer is calculated.(among all the searched subproblem states). Which makes it easy to recover the complete solution instead of only value. This can be done just by having a while loop starting at final state and iterating through prev states. 
\end{itemize}

\section{arrayDP}
\begin{itemize}
	\item Consider an array 'A' of length $2^n$. Then we need to calculate
	$$F[mask] = \sum_{i\subseteq mask}A[i]$$. This can be naively be calculated in $O(3^n)$.
	Let $$S(mask,i) = \{x|x\subseteq mask\wedge mask\oplus x < 2^{i+1}\}$$.
	Then \[ S(mask,i)=\begin{cases} 
      S(mask,i-1) & i^{th}\; bit\; OFF\; in\; mask  \\
      S(mask,i-1) \bigcup S(mask\oplus 2^i,i-1) & i^{th}\; bit\; ON\; in\; mask
   \end{cases}
\]
	(We can similarly do it for other operation than sigma).	 
	
\end{itemize}
\section{treeDP}
\begin{itemize}
	\item In some problems we root the tree at random node(r). Initially we calculate a certain property $SubProp_{u}$ for a subtree rooted at node u $\forall u \in V(vertexSet)$ in $O(n)$ using dfs. Now we can reroot the tree to one of the children of r and recompute all the $Subprop_u$ in $O(1)$ as only two $SubProp_u$'s changes(one is r and the other is the new root(selected child of r)). Template is below\\
precalculate SubProp's for random node initially. Then call the below dfs from that node.
	\begin{lstlisting}
		void dfs(int u, int par){
			\\ Now all the SubProp array is correctly calculated when u is the root. Use it.
			for(auto v:g[u]){
				if(v!=par){
					\\reroot the tree to v and adjust SubProp array correctly.
					dfs(v,u);
					\\reroot the tree to u and adjust SubProp array correctly.
				}
			}
			return;
		}
	\end{lstlisting}
\end{itemize}
\end{document}
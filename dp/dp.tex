\documentclass[../Notes.tex]{subfiles}


\begin{document}
\chapter{DP}

Write recurrence relation for a problem. When we draw a directed graph from the recurrence(i.e draw edge from state $s_i$ to all the subproblems it requires to find dp[$s_i$](i.e the right side of recurrence states)). Then in order to solve the problem the graph should be acyclic. (Then we cannot come to the answer with this dp alone, even though the recurrences are correct. You can even check if recurrences are correct between states after finding out answers with some other algorithm).

On the above graph there are three ways to solve.
\begin{itemize}
	\item Topdown dp.
	\item bottom up dp.
	\item forward dp.
\end{itemize}	
Some Points to note
\begin{itemize}
	\item Counting problems either involves combinatorics or dp and nothing else.
	\item There are counting DP problem's where we need to find no of ways to pair or group elements. We can have dp with one dimension representing no of groups which are not closed yet. This can be used both in arrays, trees etc.  
	\item we proove most optimization dp's using this kind of proving techniques.
	\href{Material/dpproof.pdf}{proof}
\end{itemize}

\section{arrayDP}

\section{treeDP}
\begin{itemize}
	\item In some problems we root the tree at random node(r). Initially we calculate a certain property $s_{u}$ for a subtree rooted at node u $\forall u \in V(vertexSet)$ in $O(n)$ using dfs. Now we can reroot the tree to one of the children of r and recompute all the $s_u$ in $O(1)$ as only two $S_u$'s changes(one is r and the other is the new root(selected child of r)).
\end{itemize}
\end{document}
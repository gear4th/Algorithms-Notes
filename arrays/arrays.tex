\documentclass[../Notes.tex]{subfiles}


\begin{document}
\chapter{Arrays}

\begin{itemize}
	\item There are 3 types(tentative) of sqrt decomp I know.
	\begin{itemize}
		\item MO's algorithm(offline algo) : When there is no query of update form then we can take all the queries and sort them in a certain way to make naive computation faster.
		\item (online algo)Divide the array in to blocks each of size ($\sqrt{n}$) and process both kind of queries in O($\sqrt{n}$) each.
		\item (online algo) Consider $\sqrt{q}$ operations at a time. Since there can be atmost $O(\sqrt{q})$ update operations. The array will be changed at atmost $\sqrt{q}$ indices hence if we find a way to answer the query operations (in this $\sqrt{q}$ block) with some preprocessing each in $O(\sqrt{q})$.\\
		 (Example. Find answer for this query without considering any updates in $O(1 \: or \: lgn)$ and update this answer according to changed indices in this range(which are only $\sqrt{q}$ in number). The time complexity of each block will be $O(q)$ hence total complexity will be $O(q\sqrt{q})$.(PreProcessing is done for each block seperately just before considering the block). \href{https://codeforces.com/problemset/problem/785/E}{Example Problem Link}.
	\end{itemize} 
	\item Let p be permutation and $next_{i}$ be the smallest $j>i$ s.t $p[j]>p[i]$. Then when we draw edges(curves) from $i -> next_{i}$ on top of the array then no two edges intersect. (i.e the condition $i<j<next_{i}<next_{j}$ is never satisfied for any pair of indices i,j).
	\item You can find number of inversions in an array using policy data structure (balance BST). Infact we can do many variations of inversion problem. (Example. Find number of inversions when equal elements are present, Which is not possible using merge sort.) 
\end{itemize}


\section{Permutation}
\begin{itemize}
	\item If we have a directed graph of n nodes, and connect ith to jth iff $p[i]=j$; then we get a bunch of disjoint cycles.
\end{itemize}

\end{document}
\documentclass[../Notes.tex]{subfiles}


\begin{document}
\chapter{C++ tricks}

\begin{itemize}
	\item In a normal set finding the $ith$ element is not possible in o(lgn)
	and it is also not possible to know number of elements less than a given value.
	\item As the above operations are theoretically possible for a balanced BST, we use policy data structure to support those two additional operations along with normal set operations. \href{https://codeforces.com/blog/entry/11080}{Blog link}
	\item But for using the above structure as a multiset, there is no easy way to do it. We will use a shortcut by inserting pair (value, time of insertion) to distinguish equal elements. And do operations around that.
	\item \texttt{\_\_gcd(x,0)} doesn't work in g++, even though its mathematically defined.
	\item While using two pointers having the second pointer ('j') pointing to the minimum index such that [i,j) subarray satisfies the condition eases the code most of the times. (instead of [i,j]).
	\item Use mt19937 instead of rand().(due to low max value, and periodicity).
	\begin{lstlisting}
		mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
		int RandomOutput = rng(); \\ generate a random number.
		shuffle(a.begin(),a.end(),rng); \\ shuffle array a.
	\end{lstlisting}
	\item when generating random trees to test your solution. Donot generate bigger size trees because edge cases will be missed(Probability that the tree will be a line is almost zero for bigger size).Similarly for the arrays too.
	\item when you write code to return while in the input loop. Beware this problem doesnot contain different test cases.
\end{itemize}

List of good to remember time complexities.
\begin{itemize}
	\item map $1e7$ random insertions 10sec.
	\item unorderedMap $1e7$ random insertions 5sec.
	\item unorderedMap with custom hash $1e7$ random insertions 5sec.
	\item set/multiset $1e7$ random insertions 10sec.
	\item $1e7$ Random vector lowerBounds on array of size $2e5$ 327ms.
	\item SegTree $1e7$ random operations(which includes both updates and queries) 1.8sec.
	\item Lazy SegTree $1e7$ random operations(which includes both updates and queries) 12sec.  
\end{itemize}

\section{STL}
\begin{itemize}
	\item List has a huge constant factor, this is due to allocation of memory on heap when an insert operation is used, the memory is not contiguous to travel easily etc. And mostly due to cache non-friendly behaviour (as the memory is not contiguous).
\end{itemize}

\end{document}
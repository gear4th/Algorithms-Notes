\documentclass[../Notes.tex]{subfiles}


\begin{document}
\chapter{Graphs}

In OJ's most of the problems concerning MST's can be solved with Kruskal's algorithm.(others are Prim's and Boruvka's).\\ 

There are certain kind of problems where number of edges are huge. They are not given in the input but told to us using certain properties of vertices. (Example. There are n nodes and each has a value $a_{i}$. There is an edge between i and j iff $a[i]\oplus a[j]==k$).
\begin{itemize}
	\item Sometimes these problems can be solved by adding some more nodes to the graph(may be nodes spanning all p-bit numbers) and connecting the real vertices with new vertices. The property for the graph(ex.number of components) asked in the question may remain same for the new graph and now edges may be less.
\end{itemize}

Let $d(u,v) =$ shortest path b/w $u,v$. Then $d(u,v,i)$ s.p passing through $i$ is $d(u,i)+d(v,i)$. similary s.p passing through edges $(i,j)$ is $min(d(u,i)+d(j,v),d(u,j)+d(i,v))+w(i,j)$.\\

A graph is bipartite $\iff$ there is no odd cycle in the graph.\\

Given a graph with both directed and undirected edges. If there are no cycles using only directed edges, we can always direct all undirected edges without forming a cycle.\href{./Material/Making undirected edges direct.pdf}{proof}.\\
Normally problems like above involve eulerian cycle and direct edges according to that.\\

There are only tree edges and back edges in dfs-tree of undirected graph. Unlike in dag's can have cross edges extra.\\

In an undirected graph an edge($v\rightarrow to$ where (v,to) is tree edge in dfs-tree) is a bridge $\iff$ there is no backedges from one of to's descendants to any v's ancestor node. This can be checked by having a value $high_u$ at every node, corresponding to highest node which is adjacent to u in original graph. And by checking if the minimum among descendant nodes is higher than our bridge. Or we can use intime of dfs traversal to check instead of depth as criteria.

\section{Trees}

These are the different ways we approach problems based on trees.
\begin{itemize}
	\item Tree dp.
	\item Normal dfs (greedy version of dp approach).
	\item Process nodes from lowest level to top.(leaves to root).
	\begin{lstlisting}
	void dfs(int u, int par){
		for(auto v:g[u]){
			if(v!=par){
				dfs(v,u);	//recursively solve for all the subtrees
			}
		}
		//When the function reaches this step all the children will be proceseed.Now use the children's information to solve for u.
		/*
			actual code.
		*/
		return;
	}
	\end{lstlisting}
	\item start time, end time on nodes.
	\item binary lifting.
	\item Using Lowest common ancestor (this can be done using binary lifting).
	\item sqrt decomposition on trees.
	\item rerooting.
\end{itemize}

While performing tree dp we can keep a map (of values in the subtree) at each node. This is a very generic trick and seems to have high potential.

we will traverse the tree from the down most level (level wise).

\begin{itemize}
	\item Have maps at each of the lowest level nodes.(each map has only one entry)
	\item Now when we go up to produce map of node 'u' in this level.\\
	Take the largest map among children of u and add remaining children maps in to this big map. Now add the value corresponding to 'u' to the map. Now this map is the final map for 'u'.
	\item Since when each node moves from one map m1 to other m2, $sizeof(m2) \geq sizeof(m1)$. Final size of m2 after addition will be $\geq 2*sizeof(m1)$. So any node will change maps only $lg(n)$ times. So the time complexity is $O(nlg(n))$.
	\item The memory is $O(n)$ throught out the procedure. Since we are inserting smaller maps in to the big map(which is already present).
	\item This can be implemented using dfs.
\end{itemize}

In DSU, while performing dsu one of the three types of techniques is used.
\begin{itemize}
	\item Path Compression \\
	\begin{lstlisting}
	Find(x)
    	if x.parent != x
     		x.parent := Find(x.parent)
	return x.parent
   	\end{lstlisting}
   	
   	\item Path Halving \\
   	\begin{lstlisting}
   	Find(x)
   		while x.parent != x
     		x.parent := x.parent.parent
     		x := x.parent
   	return x
   \end{lstlisting}
   
   \item Path Splitting.
\end{itemize}
In the problems where we need a pointer to an ancestor in a tree (or similarly in the array) and update operations makes you add more links then Path compression is useful. Example \\

Given a tree with each node having a value $a_{i}$. There are two kind of operations\\
Update : update $a_{i}$ with c where $c<a_{i}$.\\
Query : Given u. Find the deepest node with value $>= k$ which is ancestor of u.

In similar problems (having pointer in tree or array) we can use binary lifting on pointer's sometimes.


\end{document}